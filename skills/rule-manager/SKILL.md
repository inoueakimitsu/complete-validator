---
name: rule-manager
description: >-
  rules/ ディレクトリのバリデーション ルールの追加、編集、整理を支援します。
  ルール追加、ルール整理、コーディング規約からのルール生成、
  suppressions.md の管理に使用してください。
---

# Rule Manager

`rules/` ディレクトリ内のバリデーション ルールの追加、編集、整理を支援するスキルです。

## ルール ファイルの基本構造

ルール ファイルは以下の構造を持ちます。

1. **YAML フロント マター**: `applies_to` でルールの適用対象を glob パターンで指定 (必須)
2. **`# ` 見出し**: ファイル全体のタイトル (1 つ)
3. **`## ` 見出し**: 各ルールの区切り (1 つの `## ` セクション = 1 つのルール)
4. **ルール説明**: AI が機械的に判定できる具体的な説明
5. **Bad/Good 例**: コード ブロックによる違反例と正しい例のペア

詳細なテンプレートは `references/rule-template.md` を参照してください。

## ルールの追加手順

以下のワーク フローに従ってルールを追加します。

### Step 1: ヒアリング

ユーザーに以下を確認します。

- どのような規約、ルールを追加したいか
- 対象ファイルの拡張子、パターン (例: `*.py`、`*.md`、`*.ts`)
- 例外事項があるか

### Step 2: 既存ルールの確認

`rules/` ディレクトリ内の既存ルール ファイルを読み込み、以下を確認します。

- 同一または類似のルールが既に存在しないか
- 追加するルールと矛盾するルールがないか
- `applies_to` パターンが重複する既存ファイルがあるか

```bash
# 既存ルール ファイルの一覧
ls rules/*.md

# 各ファイルのフロント マターを確認
head -5 rules/*.md
```

### Step 3: 配置先の決定

まず、ルールの配置場所を決定します。

- **プラグイン組み込み (`rules/`)**: 全プロジェクト共通のルール
- **プロジェクト固有 (`.complete-validator/rules/`)**: 特定プロジェクトのみに適用するルール。組み込みルールと同名ファイルで nearest wins により上書きも可能

次に、ファイルの追加、編集方法を決定します。

- **既存ファイルに追加**: 同じ `applies_to` パターンかつ同じ関心事のファイルがある場合
- **新規ファイルを作成**: 新しい `applies_to` パターンまたは異なる関心事の場合

ファイル名の命名規則:

- スネーク ケースを使用 (例: `python_style.md`、`japanese_comment_style.md`)
- 内容を端的に表す名前にする
- 言語名 + 関心事が基本パターン (例: `typescript_naming.md`)

### Step 4: ルールの記述

`references/rule-template.md` のテンプレートに従い、ルールを記述します。

重要なポイント:

- ルール説明は AI が機械的に適用できる具体性で書く
- 曖昧な表現 (「適切な」「きれいな」) を避け、判定基準を明確にする
- Bad/Good 例は最低 1 ペア、理想 2-3 ペア
- 例外事項がある場合は「ただし」で始めて明示的に記述する

### Step 5: 形式検証

「形式検証チェック リスト」セクションに従い、ルールの形式を検証します。

## ルールの整理

既存ルールの整理、リファクタリングを行う際の指針です。

### ファイル分割の判断基準

- 1 ファイル内のルール数が **20 を超えた**場合 → 分割を検討
- `applies_to` が異なるルールが混在している場合 → 別ファイルに分離
- 関心事が大きく異なるルールが混在している場合 → 関心事ごとに分離

### 重複チェック

ルール追加、整理の前に、以下を確認します。

- 同じ内容のルールが別ファイルに存在しないか
- 矛盾するルールがないか (例: 「セミコロン必須」と「セミコロン禁止」)
- 包含関係にあるルールがないか (より具体的なルールに統合できないか)

## コーディング規約からのルール生成

外部のコーディング規約やスタイル ガイドからルールを生成するワーク フローです。

### Step 1: ソースの確認

ユーザーに規約のソース (URL、ドキュメント、テキスト) を確認します。

### Step 2: ルールの抽出

規約から個々のルールを抽出し、以下の形式に変換します。

- 1 つの `## ` セクション = 1 つの関心事
- 説明は AI が判定可能な具体性に変換
- Bad/Good 例を規約のサンプルコードから作成、またはユーザーのコード ベースに合わせて新規作成

### Step 3: `applies_to` の決定

規約が対象とするファイルパターンを決定します。

### Step 4: レビューと調整

生成したルールをユーザーに提示し、以下を確認します。

- プロジェクトの実情に合わない項目の除外
- 例外事項の追加
- Bad/Good 例の調整

## suppressions.md の管理

偽陽性の抑制ファイル `.complete-validator/suppressions.md` の管理ガイドです。

### 記述形式

```markdown
# Suppressions

- `<ルール ファイル名>` の <ルール名>: <抑制理由の説明>
```

### 運用ガイド

- **追記時**: どのルール ファイルのどのルールに対する抑制かを明記する
- **理由**: なぜ偽陽性と判断したかを簡潔に記述する
- **レビュー**: ルールを修正して偽陽性が解消されたら、該当する suppression を削除する
- **Git 管理**: チームで共有するため Git 管理下に置く
- suppressions の内容が変わるとキャッシュ キーが変わり、次回 commit 時に自動で再チェックされます

### suppression の代わりにルール修正を検討するケース

- 同じ偽陽性が頻発する場合 → ルール説明に例外条件を追加する方が適切
- ルールの説明が曖昧で偽陽性を招いている場合 → ルール説明をより具体的にする

## 形式検証チェック リスト

ルールを追加、編集した後、以下の全項目を確認してください。

### フロント マター

- [ ] ファイル先頭に `---` で囲まれた YAML フロント マターがある
- [ ] `applies_to` キーが存在し、glob パターンのリスト形式である (例: `["*.py"]`)
- [ ] glob パターンがファイル名のみ (パスを含まない) でマッチすることを意識している

### ルール構造

- [ ] ファイル全体のタイトルが `# ` 見出し (1 つ) で記述されている
- [ ] 各ルールが `## ` 見出しで区切られている
- [ ] 各 `## ` セクションが 1 つの関心事のみを扱っている
- [ ] ルール説明が AI にとって曖昧でなく、機械的に判定可能である

### Bad/Good 例

- [ ] 各ルールに最低 1 ペアの Bad/Good 例がある
- [ ] Bad/Good 例がコード ブロック (` ``` `) で囲まれている
- [ ] Bad 例が `**Bad:**` で、Good 例が `**Good:**` でラベル付けされている
- [ ] Bad/Good 例がルールの説明と一致している

### 例外事項

- [ ] 例外がある場合は「ただし」で始まる段落で明示されている
- [ ] 例外の条件が具体的である

## 参照ファイル

- `references/rule-template.md`: ルール ファイルのテンプレートと `applies_to` の書き方
- `references/best-practices.md`: ルール設計のベスト プラクティス
